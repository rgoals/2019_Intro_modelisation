---
title: "Introduction à la plateforme GitHub"
author: "zcoulibali"
date: "`r format(Sys.Date())`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Petites astuces pour la pratique

Le YAML en haut dans le code Marckdown, est l'information qui permettra d'exporter le document.

Mettre du texte en *italique*.

Ce texte est en **gras**.

Comment formater les titres selon le nombre de carrés.

Texte en `largeur fixe`.

Insérrer rapidement un bloc de code `ctrl+alt+i`.

Insérrer une équation comme paragraphe : l'encadrer par 2$ avant et 2$ après. Mais à l'intérieur du paragraphe, seulement par un $ de part et d'autre. Les équations utilise le `Latin`.

$$ \alpha = \frac{a}{b^2} $$

Juste pour tenter par moi-même une équation dans le paragraphe, écrivons $c^2 = a^2 + b^3$. Géniale !. La racine carrée s'écrit $\sqrt{a^2 + b^3}$.

Des codes utiles : 
- `{r, filtre-outliers}` donne le nom `filtre-outliers` au bloc de code, qui permet nommément de nommer les images créer dans le bloc de code.

- `{r, eval = FALSE, include = FALSE}` permet d’activer (`TRUE`, valeur par défaut) ou de désactiver (`FALSE`) le calcul de la cellule, puis inclure ou ne pas inclure ...

- `{r, echo = FALSE}` permet de n’afficher que la sortie de la cellule de code en n’affichant pas le code, par exemple un graphique ou le sommaire d’une régression.

- `{r, results = FALSE}` permet de n’afficher que le code, mais pas la sortie.

- `{r, warning = FALSE, message = FALSE, error = FALSE}` n’affichera pas les avertissements, les messages automatiques et les messages d’erreur.

- `{r, fig.width = 10, fig.height = 5, fig.align = "center"}` affichera les graphiques dans les dimensions voulues, alignée au centre (`"center"`), à gauche (`"left"`) ou à droite (`"right"`).

Mais se référer de préférence à l'[aide-mémoire](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) Marckdown pour plus de détails ou le langage Marckdown [ici](https://daringfireball.net/projects/markdown/basics).

On peut également exécuter rapidement du code sur une ligne avec la formulation `r`, par exemple la moyenne des nombres `\r a<-round(runif(4, 0, 10)); a` est de `\r mean(a)`, en enlevant les `\` devant les r (ajoutées artificiellement pour éviter que le code soit calculé) qui affichera en sortie :

La moyenne des nombres `r a <- round(runif(4, 0, 10)); a` est de `r mean(a)`.


## Charger le fichier de travail

Après toutes ces digressions personnelle pour implémenter certains aspects fascinants de cet interface, je reviens aux moutons à l'ordre du jour. Chargeons les données à étudier.

```{r}
library(tidyverse)
hawai <- read_csv("hawai.csv")
```

## Directives de l’évaluation
	
Les données du fichier `hawai.csv` comprennent les moyennes des mesures mensuelles de **CO2 atmosphérique** en ppm-volume collectées au Mauna-Loa Observatory à Hawaii de mars 1958 à juillet 2001, inclusivement.

## Travail à faire

Le travail consiste à :

1. créer une série temporelle du CO2 à partir des données de hawai.csv

2. séparer la série en parties d'entraînement (environ 70% des données) et en partie test

3. créer un modèle ETS sur les données d'entraînement, puis projeter la prévision de CO2 atmosphérique pour comparer aux données test

4. effectuer une analyse des résidus

5. commenter : le modèle est-il fiable ? Comment pourrait-il être amélioré ?

Enfin, le travail est remis sous forme de lien vers un répertoire git (GitHub, GitLab, etc.) comprenant un code reproductible de votre démarche en format R-markdown.

## Résolution

### 1. Créer une série temporelle du CO2 à partir des données de hawai.csv

Exploration des données :

```{r}
str(hawai)
```

La fonction `read_csv()` n'a pas reconnu la variable `time` directement comme une date mais plutôt une variable numérique. On serait tenté de la transformer en format date. Mais la fonction `ts()` du module `lubridate`, qui crée un objet de classe `ts`, n'a pas forcément besoin du format date. 

```{r}
library(forecast)
```

Il faut garder que le vecteur ou la matrice temporelle `(excluant la date: time)` puis spécifier l'unité temporelle (ici l'année) et la sous-unité (le mois) de départ, et combien il y a de sous-unités par unité temporelle (ici 12 mois). 

La série temporelle `hawai_ts` devient :

```{r}
hawai_ts <- ts(hawai$CO2,         # le vecteur (cible)
                start = c(1958, 3), # départ au 3ième mois de 1958
                freq = 12)          # nombre de sous-unités par an freq = 12
sample(hawai_ts, 10)
```

### 2. Séparer la série en parties d'entraînement (environ 70% des données) et en partie test

Après une exploration du dataframe, la série commence en mars 1958 et termine en décembre 2001. Voyons s'il peut être affiché entièrement :

```{r}
hawai_ts
```

Tentons ce code pour trouver l'année et le mois où le partitionnement en Train et Test sets devrait s'arrêter :

```{r}
hawai$time[round(0.7*nrow(hawai))]
```

Ce qui correspond au mois de septembre 1988. Nous pouvons partitionner en utilisant cette date comme ci-dessous :

```{r}
hawai_ts_train1 <- window(hawai_ts, 
                         start = 1958, 
                         end = hawai$time[round(0.7*nrow(hawai))],
                         freq = 12)
hawai_ts_test1 <- window(hawai_ts, 
                        start = hawai$time[round(0.7*nrow(hawai))],
                        freq = 12)
```

Ou bien partitionner jusqu'en décembre 1988 (3 mois de plus), juste pour que les données Test restent sur 12*13 (13 périodes de 12 mois). Y'aurait-il autre moyen de pouvoir appeler les 3 mois restant dans le `forecast(h= ...)` ? J'ai opté de les ajouter aux données d'entraînement.

```{r}
hawai_ts_train <- window(hawai_ts, 
                         start = 1958, 
                         end = 1988,
                         freq = 12)
hawai_ts_test <- window(hawai_ts, 
                        start = 1989,
                        freq = 12)
```

On pourrait visualiser le succès du partitionnement en appelant par exemple les données Test :

```{r}
hawai_ts_test
```

### 3.1 Créer un modèle ETS sur les données d'entraînement

R optimise le choix du meileur modèle avec la méthode ETS (`error, tend and seasonnal`). L’optimisation est lancée avec la fonction `ets()` du module `forecast`.

```{r}
hawai_ets <- hawai_ts_train %>%
                  ets() %>%         # enregistre le modèle
                  forecast()        # affiche la composante prévisionnelle
```

Pour afficher la prédiction :

```{r}
hawai_ets %>% 
  autoplot()
```

Une prédiction est faite possiblement de 1988 à 1990. Les données Test permettront d'etendre un peu plus cette plage de prédiction.

On pourrait regarder les paramètres du modèle :

```{r}
hawai_ets$model$par
```

### 3.2 Projeter la prévision de CO2 atmosphérique pour comparer aux données test

Faisons la projection sur 13 périodes de 12 mois (`12*13`) correspondant à la plage des données Test.

```{r}
hawai_ets <- hawai_ts_train %>%
                  ets() %>% 
                  forecast(h = 12*13)
```

La visualisation graphique donne cette fois :

```{r}
hawai_ets %>% 
  autoplot()
```



### 4. Effectuer une analyse des résidus


```{r}
hawai_ets %>% 
  checkresiduals()
```

La p-value du `Ljung-Box test` (<<< 0.05) montre qu'il y a des tendances dans les données. Il est peu probable que les résidus aient été générés par un bruit blanc, indiquant qu’il existe une structure dans les données qui n’a pas été capturée par le modèle.

### 5. Commenter : le modèle est-il fiable ? Comment pourrait-il être amélioré ?

```{r}
hawai_arima <- hawai_ts_train %>% auto.arima()
hawai_arima %>% forecast(h=12*13) %>% autoplot()
```
 




