---
title: "Introduction à la plateforme GitHub"
author: "zcoulibali"
date: "`r format(Sys.Date())`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Petites astuces

Le YAML (ci-dessus), c'est l'information qui permettra d'exporter le document.

Mettre du texte en *italique*.

Ce texte est en **gras**.

L'ordre des titres selon le nombre de carrés.

Texte en `largeur fixe`.

Insérrer un bloc de code `ctrl+alt+i`.

Insérrer une équation seule, l'encadrer par 2$ avant et 2$ après. Dans un paragraphe, seulement par un $. Les équation utilise le `Latin`:

$$ \alpha = \frac{a}{b^2} $$

L'Équation dans le paragraphe est $c^2 = a^2 + b^3$ et c'est même très beau à voir. La racine carrée est donc $\sqrt{a^2 + b^3}$.


- `{r, filtre-outliers}` donne le nom `filtre-outliers` au bloc de code, qui permet nommément de nommer les images créer dans le bloc de code.

- `{r, eval = FALSE, include = FALSE}` permet d’activer (`TRUE`, valeur par défaut) ou de désactiver (`FALSE`) le calcul de la cellule, puis inclure ou ne pas inclure ...

- `{r, echo = FALSE}` permet de n’afficher que la sortie de la cellule de code en n’affichant pas le code, par exemple un graphique ou le sommaire d’une régression.

- `{r, results = FALSE}` permet de n’afficher que le code, mais pas la sortie.

- `{r, warning = FALSE, message = FALSE, error = FALSE}` n’affichera pas les avertissements, les messages automatiques et les messages d’erreur.

- `{r, fig.width = 10, fig.height = 5, fig.align = "center"}` affichera les graphiques dans les dimensions voulues, alignée au centre (`"center"`), à gauche (`"left"`) ou à droite (`"right"`).

On peut également exécuter rapidement du code sur une ligne avec la formulation `r`, par exemple la moyenne des nombres `\r a<-round(runif(4, 0, 10)); a` est de `\r mean(a)`, en enlevant les `\` devant les r (ajoutées artificiellement pour éviter que le code soit calculé) sera la moyenne des nombres 7, 2, 2, 8 est de 4.75

La moyenne des nombres `r a <- round(runif(4, 0, 10)); a` est de `r mean(a)`.


## Charger le fichier de travail

```{r, results=FALSE}
library(tidyverse)
hawai <- read_csv("hawai.csv")
```


## Directives de l’évaluation
	
Les données du fichier `hawai.csv` comprennent les moyennes des mesures mensuelles de **CO2 atmosphérique** en ppm-volume collectées au Mauna Loa Observatory à Hawaii de mars 1958 à juillet 2001, inclusivement.

## Trvail à faire

Votre travail consiste à :

1. créer une série temporelle du CO2 à partir des données de hawai.csv

2. séparer la série en parties d'entraînement (environ 70% des données) et en partie test

3. créer un modèle ETS sur les données d'entraînement, puis projeter la prévision de CO2 atmosphérique pour comparer aux données test

4. effectuer une analyse des résidus

5. commenter: le modèle est-il fiable ? Comment pourrait-il être amélioré ?

Vous devez me remettre un lien vers un répertoire git de votre choix (GitHub, GitLab, etc.) comprenant un code reproductible de votre démarche en format R-markdown.

## Prediction avec des séries temporelles

```{r}
str(hawai)
```

## Résolution

### 1. Créer une série temporelle du CO2 à partir des données de hawai.csv

La fonction `read_csv()` n'a pas reconnu la variable `time` directement comme une date mais plutôt une variable numérique. Il faut alors pouvoir passer à une variable sous forme de date. 

Le format `ts` pour `time series` permis par la fonction `ts()` du package `lubridate` n'a pas besoin du format de date. On ne garde que le vecteur ou la matrice temporelle `(excluant la date: time)`, on spécifie l'unité temporelle (l'année) et la sous-unité (le mois) de départ (ici l'année), puis à spécifier combien il y a de sous-unité par unité. La série temporelle `hawai_ts` est:

```{r}
hawai_ts <- ts(hawai$CO2,         # le vecteur (cible)
                start = c(1958, 3), # départ au 3ième mois de 1958
                freq = 12)          # nombre de sous-unités par an freq = 12
sample(hawai_ts, 10)
```

### 2. Séparer la série en parties d'entraînement (environ 70% des données) et en partie test

```{r}
hawai$time[round(0.7*nrow(hawai))]-1/365.25
```

```{r}
hawai$time[round(0.7*nrow(hawai))]-1/365.25
```



```{r}
hawai_ts_train <- window(hawai_ts, 
                         start = 1958, 
                         end = hawai$time[round(0.7*nrow(hawai))]-1/365.25,
                         freq = 12)
hawai_ts_test <- window(hawai_ts, 
                        start = hawai$time[round(0.7*nrow(hawai))],
                        freq = 12)
```

```{r}
hawai_ts_train
```


```{r}
hawai_ts_test
```

### 3.1 Créer un modèle ETS sur les données d'entraînement
On peut laisser R optimiser le choix avec un modèle avec ETS (`error, tend and seasonnal`). L’optimisation est lancée avec la fonction `ets()` du module `forecast`.

```{r}
library(forecast)
```

```{r}
hawai_ets <- hawai_ts_train %>%
                  ets() %>%         # enregistre le modèle
                  forecast()        # affiche la composante prévisionnelle
hawai_ets %>% 
  autoplot()
```

```{r}
hawai_ets$model$par
```

### 3.2 Projeter la prévision de CO2 atmosphérique pour comparer aux données test

Les données test partent du mois d'octobre 1988 au mois de décembre 2001 soit 13 périodes de 12 mois plus 3 mois. Faisons la projection sur 13 périodes de 12 mois (`12*13`).

```{r}
hawai_ets <- hawai_ts_train %>%
                  ets() %>% 
                  forecast(h = 12*13)
hawai_ets %>% 
  autoplot()
```

### 4. Effectuer une analyse des résidus


```{r}
hawai_ets %>% 
  checkresiduals()
```

La p-value du `Ljung-Box test` (<<< 0.05) montre qu'il y a des tendances dans les données. Il est peu probable que les résidus aient été générés par un bruit blanc, indiquant qu’il existe une structure dans les données qui n’a pas été capturée par le modèle.

### 5. Commenter: le modèle est-il fiable ? Comment pourrait-il être amélioré ?

```{r}
hawai_arima <- hawai_ts_train %>% auto.arima()
hawai_arima %>% forecast(h=12*13) %>% autoplot()
```
 




